<!DOCTYPE html>
<html lang="ja">
<head>
    <base target="_top">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>会員記事一覧</title>

<!-- Firebase compat CDN (v9.6.10と揃える) -->
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
<script>
  // ★記事JSONを返すWorkerのベースURL（末尾スラッシュ不要）
  window.WORKER_URL = "https://kjd-article-api.ecj19830411.workers.dev";
</script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-GBHXS22T9R"></script>

<script>

// ✅ 旧初期化も無効化
window.initFirestoreLoader = () => console.info("[init] Firestore init DISABLED");


</script>





<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-GBHXS22T9R');
</script>

<script>
window.addEventListener('error', e => {
  console.error('[FATAL]', e.error || e.message);
  const el = document.getElementById('initialLoadingMessage');
  if (el) el.textContent = `スクリプトエラー: ${e.message}`;
});
window.addEventListener('unhandledrejection', e => {
  console.error('[UNHANDLED]', e.reason);
  const el = document.getElementById('initialLoadingMessage');
  if (el) el.textContent = `未処理エラー: ${e.reason?.message || e.reason}`;
});
</script>


<!-- ★ここに “唯一の” Firebase初期化ブロック を置く（スタイルより前） -->
<script>
(() => {
  "use strict";

  const firebaseConfig = {
    apiKey: "AIzaSyAJT3EnF4s6kfU6RuC9nJvOrs9FtG_RMR0",
    authDomain: "economic-journals-digital.firebaseapp.com",
    projectId: "economic-journals-digital",
    storageBucket: "economic-journals-digital.appspot.com",
    messagingSenderId: "1032175762907",
    appId: "1:1032175762907:web:e46fca907bb52c9b5fbbfe"
  };

  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);

  window.auth = firebase.auth();
  window.db   = firebase.firestore();
  window.LOGIN_URL = 'login.html';

  // ★ グローバル記事データは window.* に
  window.allArticles = [];
  window.categoryMap = {};
  let _authFired = false;

  window.firebaseReady = Promise.resolve();
})();
</script>

<script>
  // window に載せたものを、この script スコープ用に束縛する
  const auth = window.auth;
  const db   = window.db;
</script>

<script>
(function guardMemberPage() {
  const LOGIN_URL = window.LOGIN_URL || 'login.html';

  // auth がまだ無い時の保険（読み込み順で事故るのを防ぐ）
  if (!window.auth || !window.auth.onAuthStateChanged) {
    console.error('[auth] window.auth is not ready');
    return;
  }

  window.auth.onAuthStateChanged(async (user) => {
    if (!user) {
      // 未ログイン → loginへ
      location.replace(LOGIN_URL);
      return;
    }

    // ログイン済み → ここで初めてページの本処理を開始
    console.log('[auth] signed in:', user.uid);

    // 例）あなたの記事読み込み開始関数があるならここで呼ぶ
    // await loadArticles();
  }, (err) => {
    console.error('[auth] onAuthStateChanged error', err);
    // ここで落ちると保護が壊れるので、表示も変えると親切
    const el = document.getElementById('initialLoadingMessage');
    if (el) el.textContent = '認証状態の取得に失敗しました（再読み込みしてください）';
  });
})();
</script>



<link rel="stylesheet" href="style.css">



</head>
<body>
    <div class="fixed-container">
<div class="header-bar">
  <div class="header-inner">
    <div class="left-section">
      <div class="logo-container">
        <a href="http://www.economicjournal.co.jp/" target="_blank">
          <img src="https://lh3.googleusercontent.com/d/1k-sttTgkKJv6eZE9X2N34fSQFjXWpH8u" alt="economic jornal">
        </a>
      </div>
      <div class="tagline">Members Page</div>
    </div>

    <div class="top-links">
      <a href="#tokutei" class="legal-link">特定商取引法表示</a>
      <a href="#" id="logoutLink" onclick="doLogout(event)">ログアウト</a>
    </div>
  </div>
</div>
        <div class="filter-bar">
            <div class="filter-bar-content">
                <input type="text" id="searchInput" placeholder="キーワードで検索"
       onkeyup="if(event.key === 'Enter') window.searchArticles()">
                <select id="yearFilter" onchange="filterResults()">
                    <option value="all">すべての年</option>
                </select>
                <select id="categoryFilter" onchange="filterResults()">
                    <option value="all">カテゴリ別</option>
                </select>
                <button onclick="window.searchArticles()">検索</button>
                <button onclick="window.resetSearch()">リセット</button>
            </div>
        </div>
    </div>

<!-- ▼ Filter bar と 記事一覧の間 -->
<div id="latest-issue-cta">
  <div class="latest-issue-row">
    <button id="btn-latest-issue" type="button">最新号を読む</button>
    <span id="latest-issue-cta-sub">（電子書籍式ビューアへ移動します）</span>
  </div>
</div>
<!-- ▲ ここまで -->


    <main>
        <div id="searchResults">
            <div class="auth-message" id="initialLoadingMessage">認証を確認中...</div>
        </div>
    </main>




    <button id="page-top">TOP</button>

<script>


const ISSUE_PREFIX = 'No.';


function issueLabel(raw, pad = 4) {
  if (raw == null) return '';
  const digits = String(raw).replace(/\D/g, ''); // 数字だけ抽出（No.2525 → 2525）
  if (!digits) return '';
  const padded = pad ? digits.padStart(pad, '0') : digits;
  return `${ISSUE_PREFIX} ${padded}`;
}

// "YYYY/MM/DD" or "YYYY-MM-DD" → "M/D"
function formatMonthDay(ymd){
  if (!ymd) return '';
  const s = String(ymd).replace(/-/g, '/');
  const m = s.match(/^(\d{4})\/(\d{1,2})\/(\d{1,2})$/);
  if (!m) return '';
  const mm = String(parseInt(m[2], 10));
  const dd = String(parseInt(m[3], 10));
  return `${mm}/${dd}`;
}



async function ensureMiniSearchLoaded(timeoutMs = 8000) {
  const start = Date.now();
  while (!window.MiniSearch) {
    await new Promise(r => setTimeout(r, 100));
    if (Date.now() - start > timeoutMs) {
      console.warn('[IDX] MiniSearch not loaded yet');
      return false;
    }
  }
  return true;
}

</script>

<script>

    // --- ログアウト関数 ---
function doLogout(event) {
  event.preventDefault();
  if (confirm('ログアウトしますか？')) {
    window.auth.signOut().then(() => {
      console.log('ログアウト成功');
    }).catch((error) => {
      console.error("ログアウト中にエラーが発生しました:", error);
      alert("ログアウトに失敗しました。");
    });
  }
}





function enhanceArticleLinks(scope = document) {
  const root = scope.querySelector('.content') || scope;

  root.querySelectorAll('a[href], a[data-article-id]').forEach(a => {
    const rawHref = a.getAttribute('href') || '';
    const dataId  = a.dataset.articleId;

    // 1) #open:<docId> / data-article-id で内部記事を開く
    let targetId = dataId || (rawHref.startsWith('#open:') ? rawHref.slice(6) : null);

    // 2) #issue:<number> なら号数から docId を引く
    if (!targetId && rawHref.startsWith('#issue:')) {
      const no = rawHref.slice(7).replace(/\D/g,'');
      const hit = (window.allArticles || []).find(a => String(a.issueNumber||'').replace(/\D/g,'') === no);
      if (hit) targetId = hit.articleId;
    }

    if (targetId) {
      a.addEventListener('click', e => {
        e.preventDefault(); e.stopPropagation();
        showArticlePopup(targetId);     // ← 既存の関数を再利用
      }, { passive:false });
      a.setAttribute('href', '#');      // 予防：ページ遷移しない
      return;
    }

    // 3) 外部リンクは新規タブで安全に
    if (/^https?:\/\//i.test(rawHref)) {
      a.setAttribute('target', '_blank');
      a.setAttribute('rel', 'noopener');
    }
  });
}



</script>

<script>





// 一覧用：<br> / \n / 実改行 / &nbsp; / 全角スペース などを除去し、余計な空白を詰めて1行に整形
function oneLineTitle(raw) {
  if (!raw) return '';
  return String(raw)
    .replace(/&lt;\s*br\s*\/?&gt;/gi, ' ') // エスケープ済み <br> → 空白
    .replace(/<\s*br\s*\/?>/gi, ' ')       // 実際の <br> → 空白
    .replace(/\\n/g, ' ')                  // 文字列の \n → 空白
    .replace(/\r?\n/g, ' ')                // 実際の改行 → 空白
    .replace(/&nbsp;/gi, ' ')              // &nbsp; → 空白
    .replace(/\u00A0/g, ' ')               // NBSP → 空白
    .replace(/\u3000/g, ' ')               // 全角スペース → 半角空白
    .replace(/<\/?[^>]+>/g, ' ')           // 念のため他のタグも除去
    // --- 文字詰め（空白の不要箇所を削る）---
    .replace(/\s*([、。，．：；／？！）」』】〉》\)\]\}])/g, '$1') // 閉じ系句読点の直前空白を削除
    .replace(/([（「『【〈《\(\[\{])\s*/g, '$1')                  // 開き系の直後空白を削除
    .replace(/\s*\/\s*/g, '/')                                    // スラッシュの前後空白を削除
    .replace(/\s{2,}/g, ' ')                                      // 連続空白→1個
    .trim();
}

// ポップアップ用：安全にエスケープした上で、<br> / \n / 文字列の \n を改行として復元
function renderWithManualBreaks(raw) {
  if (!raw) return '';
  const escaped = String(raw)
    .replace(/&/g, '&amp;')  // まず危険な記号を全部エスケープ
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  return escaped
    .replace(/&lt;br\s*\/?&gt;/gi, '<br>') // 文字列内の "<br>" を改行化
    .replace(/\\n/g, '<br>')               // 文字列の \n を改行化（クォート内の \n）
    .replace(/\r?\n/g, '<br>');            // 実際の改行も改行化
}


// CJKは1文字単位、英数は単語ごとに分割して行折返しを安定化
function plainTextFromHtml(html = "") {
  if (!html) return "";
  // <style>～</style> を丸ごと除去
  let body = String(html).replace(/^[\s\S]*?<\/style>/i, "");
  // <div class="article-content"> ～ </div> の中身だけを抽出（あれば）
  body = body.replace(
    /^\s*<div[^>]*class=["'][^"']*article-content[^"']*["'][^>]*>([\s\S]*?)<\/div>\s*$/i,
    "$1"
  );

  const div = document.createElement("div");
  div.innerHTML = body;
  return (div.textContent || "")
    .replace(/\u00A0/g, " ")      // nbsp → 半角スペース
    .replace(/\u3000/g, " ")      // 全角スペース → 半角
    .replace(/\s{2,}/g, " ")      // 連続空白 → 1個
    // 文字詰め（空白の不要箇所を削る）
    .replace(/\s*([、。，．：；／？！）」』】〉》\)\]\}])/g, "$1") // 閉じ系直前の空白を削除
    .replace(/([（「『【〈《\(\[\{])\s*/g, "$1")                  // 開き系直後の空白を削除
    .replace(/\s*\/\s*/g, "/")                                   // スラッシュ前後の空白を削除
    .trim();
}

// 改行コードや <br> を可視改行に（ポップアップ用）
function convertBrToNewline(str = '') {
  if (!str) return '';
  return String(str)
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/\r\n?/g, '\n');
}





// === Unicode property escape を使わない CJK 定義 ===
// 漢字: U+3400-9FFF, 互換: U+F900-FAFF
// ひらがな: U+3040-309F, カタカナ: U+30A0-30FF, 片拡張: U+31F0-31FF, 半角カナ: U+FF65-FF9F
const RE_CJKLIKE_GLOBAL = /[\u3400-\u9FFF\uF900-\uFAFF\u3040-\u309F\u30A0-\u30FF\u31F0-\u31FF\uFF65-\uFF9F]/g;
const RE_CJKLIKE_SINGLE = /[\u3400-\u9FFF\uF900-\uFAFF\u3040-\u309F\u30A0-\u30FF\u31F0-\u31FF\uFF65-\uFF9F]/;
const RE_NOT_CJK_ALNUM = /[^A-Za-z0-9\u3400-\u9FFF\uF900-\uFAFF\u3040-\u309F\u30A0-\u30FF\u31F0-\u31FF\uFF65-\uFF9F]+/g;
const RE_TOKEN_OK       = /^[A-Za-z0-9\u3400-\u9FFF\uF900-\uFAFF\u3040-\u309F\u30A0-\u30FF\u31F0-\u31FF\uFF65-\uFF9F]+$/;




// MiniSearch ヘルパ（重複定義があれば片方に統一）
// --- MiniSearch helpers（このブロックは1セットだけにする） ---

function tokenizeJa(str) {
  if (window.TinySegmenter) {
    const seg = new TinySegmenter();
    return seg.segment(String(str)).filter(t => /\S/.test(t));
  }
  return String(str).split(/[\s、。．・,.\-\/\s]+/).filter(Boolean);
}

</script>

<script>

// ====== 設定 ======
const MIN_ISSUE_TO_LINK = 1902; // 2020/04～ の下限

// ====== 1) 「→ No.2153」などを本文内で自動リンク化 ======
function linkifyIssueRefs(scope = document) {
  const root = scope.querySelector('.content') || scope;

  // TextNodeを歩いて 内は無視
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
    acceptNode(node) {
      if (!node.nodeValue || !/No\.?\s*\d{3,4}/i.test(node.nodeValue)) return NodeFilter.FILTER_REJECT;
      const p = node.parentElement;
      if (!p || p.closest('a,code,pre,script,style')) return NodeFilter.FILTER_REJECT;
      return NodeFilter.FILTER_ACCEPT;
    }
  });

  const targets = [];
  while (walker.nextNode()) targets.push(walker.currentNode);

  const RE = /(?:→\s*)?(No\.?\s*(\d{3,4}))/gi; // 例: "→ No.2153" / "No2153"
  targets.forEach(node => {
    const frag = document.createDocumentFragment();
    const src = node.nodeValue;
    let last = 0, m;
    while ((m = RE.exec(src)) !== null) {
      const before = src.slice(last, m.index);
      if (before) frag.appendChild(document.createTextNode(before));

      const num = parseInt(m[2], 10);
      const label = `No. ${num}`;

      if (num >= MIN_ISSUE_TO_LINK) {
        // 既知なら articleId を、未登録なら pending として置く
        const hit = (window.allArticles || []).find(a =>
          String(a.issueNumber || '').replace(/\D/g,'') === String(num)
        );

        const a = document.createElement('a');
        a.textContent = label;
        a.href = `#issue:${num}`;
        a.className = 'auto-issue-link' + (hit ? '' : ' pending');
        if (hit) {
          a.dataset.articleId = hit.articleId;
        } else {
          a.dataset.issue = String(num);
          a.title = '準備中';
        }
        frag.appendChild(a);
      } else {
        // 下限未満はそのままテキストに戻す
        frag.appendChild(document.createTextNode(m[1]));
      }
      last = RE.lastIndex;
    }
    const tail = src.slice(last);
    if (tail) frag.appendChild(document.createTextNode(tail));
    node.replaceWith(frag);
  });
}

// ====== 2) 未登録(準備中)リンクを、登録済みなら即・有効化 ======
function resolvePendingIssueLinks(scope = document) {
  const root = scope.querySelector('.content') || scope;
  root.querySelectorAll('a.auto-issue-link.pending').forEach(a => {
    const num = a.dataset.issue || (a.textContent.match(/\d{3,4}/)||[])[0];
    const hit = (window.allArticles || []).find(x =>
      String(x.issueNumber || '').replace(/\D/g,'') === String(num)
    );
    if (hit) {
      a.classList.remove('pending');
      a.removeAttribute('title');
      a.dataset.articleId = hit.articleId;
    }
  });
  // クリックハンドラを新しいリンクにも付与
  enhanceArticleLinks(root);
}











</script>

<script>

// 入力ゆれ対策：NFKC＋連続空白つぶし
function normalizeJaQuery(s = '') {
  return String(s).normalize('NFKC').replace(/[ \u3000]+/g, ' ').trim();
}


// --- ここから追加（tokenizeJa の直後）---
function _normalizeJa(s = '') {
  return String(s).normalize('NFKC').replace(/\s+/g, ' ').trim();
}

// 会社表記や表記ゆれも含めた日本語正規化（インデックス側と同等）
const COMPANY_MARKERS = /(株式会社|（株）|\(株\)|㈱|有限会社|（有）|\(有\)|㈲|合同会社|（同）|\(同\)|一般社団法人|（一社）|一般財団法人|（一財）|学校法人|医療法人|社会福祉法人)/g;
const STOPWORDS = new Set(['が','の','は','を','に','へ','と','で','も','や','より','から','まで','ので','なら','って','にて','として']);

function normalizeJaText(s){
  if (!s) return '';
  let t = String(s).normalize('NFKC').toLowerCase();
  t = t.replace(COMPANY_MARKERS, ''); // ← ここで㈱（株）等を削除
  // ひらがな→カタカナ（表記ゆれ吸収）
  t = t.replace(/[\u3041-\u3096]/g, ch => String.fromCharCode(ch.charCodeAt(0)+0x60));
  // 記号類を空白化（漢字/カタカナ/英字/数字だけ残す）
  t = t.replace(/[^A-Za-z0-9\u3400-\u9FFF\uF900-\uFAFF\u30A0-\u30FF\u31F0-\u31FF\uFF65-\uFF9F]+/g, ' ');
  return t.trim();
}


// 2文字バイグラム + 先頭2-4文字プレフィックスも足す
function tokenizeJaPlus(str){
  const txt = normalizeJaText(str);
  let tokens;
  if (window.TinySegmenter) {
    const seg = new TinySegmenter();
    tokens = seg.segment(txt);
  } else {
    tokens = txt.split(/\s+/);
  }
  tokens = tokens.filter(t => t && !STOPWORDS.has(t));

  const extras = [];
  for (const t of tokens) {
    if (!RE_TOKEN_OK.test(t)) continue;

    // 略称（頭文字）対策：先頭2〜4文字
    for (let k=2; k<=Math.min(4, t.length); k++) extras.push(t.slice(0, k));

    // 部分一致対策：2文字バイグラム（経常/常収/収益 など）
    if (t.length >= 2) {
      for (let i=0; i<t.length-1; i++) extras.push(t.slice(i, i+2));
    }
  }
  return tokens.concat(extras);
}




  
const _idxCache = {}; // { y2025: MiniSearch, ... }

async function loadIndexShard(key) {
  // key: "2025-H1" など。従来の "2025" だけでもOK
  const shardDocId = /^y/.test(key) ? key : `y${key}`; // "2025-H1" → "y2025-H1"
  if (_idxCache[shardDocId]) return _idxCache[shardDocId];

  try {
    const snap = await db.collection('search_indexes').doc(shardDocId).get();
    if (!snap.exists) return null;

    const raw = snap.data().json;
    const jsonStr = (typeof raw === 'string') ? raw : JSON.stringify(raw);

    // ★（任意）安全マージンのログ
    const bytes = new TextEncoder().encode(jsonStr).length;
    if (bytes > 800_000) console.warn(`[IDX] ${shardDocId} ~${(bytes/1024).toFixed(1)}KB (near 1MiB)`);

    const idx = MiniSearch.loadJSON(jsonStr, {
      fields: ['title','plainContent','keywords','bigrams'],
      storeFields: ['articleId','title','issue','publishDate'],
      tokenize: tokenizeJaPlus,
      searchOptions: { prefix:true, fuzzy:0.1, combineWith:'AND',
        boost: { title:5, keywords:3, plainContent:1, bigrams:0.7 } }
    });

    _idxCache[shardDocId] = idx;
    return idx;
  } catch (e) {
    console.warn(`[IDX] failed to load shard: ${shardDocId}`, e);
    return null;
  }
}


// ★ シャード一覧を _meta から1回だけ取得（フォールバックはコレクション走査）
// 形式例: ["2025-H2","2025-H2-2","2025-H1","2024-H2", ...]
let _availableIndexShardsCache = null;

async function getAvailableIndexShards(forceRefresh = false) {
  if (_availableIndexShardsCache && !forceRefresh) return _availableIndexShardsCache;

  try {
    const snap = await db.collection('search_indexes').doc('_meta').get();
    if (snap.exists) {
      const arr =
        (Array.isArray(snap.data()?.years) && snap.data().years) ||
        (Array.isArray(snap.data()?.list) && snap.data().list) ||
        null;
      if (arr && arr.length) {
        _availableIndexShardsCache = arr;
        return arr;
      }
    }
  } catch (e) {
    console.warn('[IDX] _meta read failed → scan fallback', e);
  }

  // フォールバック：search_indexes をざっと走査
  const s = await db.collection('search_indexes').get();
  const list = s.docs
    .map(d => (d.id.match(/^y(\d{4}(?:-H[12])?(?:-\d+)?)$/) || [,''])[1])
    .filter(Boolean);
  _availableIndexShardsCache = list;
  return list;
}




// 候補IDのうち「正規化した本文に正規化したクエリが連続出現する」ものだけ残す
async function enforcePhraseOnCandidates(ids, phrase, limit = 25) {
  // 正規化：NFKC / ひら→カナ / 記号除去 / 小文字
  const norm = s => String(s)
    .normalize('NFKC')
    .replace(/[\u3041-\u3096]/g, ch => String.fromCharCode(ch.charCodeAt(0)+0x60))
    .replace(/[^A-Za-z0-9\u3400-\u9FFF\uF900-\uFAFF\u3040-\u309F\u30A0-\u30FF\u31F0-\u31FF\uFF65-\uFF9F]+/g, '')
    .toLowerCase();

  const target = norm(phrase);
  if (!target) return ids;

  // もともとの順序を保持できるようにマップ化
  const order = new Map(ids.map((id, i) => [id, i]));

  const out = [];
  const max = Math.min(ids.length, limit);

  // Firestore の where(documentId(), 'in', [...]) は 10 件まで → 10件ずつ分割
  for (let i = 0; i < max; i += 10) {
    const chunk = ids.slice(i, Math.min(max, i + 10));
    const snap = await db.collection('articles')
      .where(firebase.firestore.FieldPath.documentId(), 'in', chunk)
      .get();

    snap.forEach(doc => {
      const html = doc.data()?.htmlContent || '';
      const text = htmlToPlainTextForIndex(html);
      if (norm(text).includes(target)) out.push(doc.id);
    });
  }

  // もとの順序で並べ替えて返す
  return out.sort((a, b) => (order.get(a) ?? 1e9) - (order.get(b) ?? 1e9));
}


// CJK or 英数の1文字判定（ひら/カタカナ拡張・半角カナも含む）
const isCjkOrAlnum = ch =>
  /[\u3400-\u9FFF\uF900-\uFAFF\u3040-\u30FF\u31F0-\u31FF\uFF65-\uFF9FA-Za-z0-9]/.test(ch);

// 検索語を正規化し、語＋2文字バイグラムへ分解
function queryTerms(q) {
  const s = normalizeJaText(q); // ㈱/（株）なども除去済み
  const terms = tokenizeJaPlus(s).filter(t => t.length >= 2 && !STOPWORDS.has(t));

  // クエリ側も CJK 2-gram を作る（bigrams フィールド用）
  const grams = [];
  const t = s.normalize('NFKC').replace(/\s+/g, '');
  for (let i = 0; i < t.length - 1; i++) {
    const a = t[i], b = t[i + 1];
    if (isCjkOrAlnum(a) && isCjkOrAlnum(b)) grams.push(a + b);
  }
  // ユニーク化して返す
  return { terms: Array.from(new Set(terms)), grams: Array.from(new Set(grams)) };
}


function smartSearch(idx, rawQuery) {
  const q = normalizeJaText(rawQuery);
  if (!q) return [];

  // CJK 文字数が多い or スペースを含む → 長いフレーズとして扱う
  const RE_CJKLIKE_GLOBAL = /[\u3400-\u9FFF\uF900-\uFAFF\u3040-\u309F\u30A0-\u30FF\u31F0-\u31FF\uFF65-\uFF9F]/g;
  const isLongPhrase = (q.match(RE_CJKLIKE_GLOBAL) || []).length >= 6 || /\s/.test(rawQuery);

  // クエリ側 CJK バイグラム（順序は見ないが AND で厳しく）
  const RE_CJKLIKE_SINGLE = /[\u3400-\u9FFF\uF900-\uFAFF\u3040-\u309F\u30A0-\u30FF\u31F0-\u31FF\uFF65-\uFF9F]/;
// クエリ側 CJK バイグラム（順序は見ないが AND で厳しく）
const grams = (() => {
  const t = q.normalize('NFKC').replace(/\s+/g, '');
  const out = [];
  for (let i = 0; i < t.length - 1; i++) {
    const a = t[i], b = t[i + 1];
    if (isCjkOrAlnum(a) && isCjkOrAlnum(b)) out.push(a + b);
  }
  return Array.from(new Set(out));
})();

  // (A) bigrams 検索を少し緩め（2文字社名の拾い上げ強化）
if (grams.length) {
  const rA = idx.search(grams.join(' '), {
    fields: ['bigrams','title','keywords'],
    combineWith: 'OR', // ← AND→ORに変更
    prefix: true,      // ← 部分一致許可
    fuzzy: 0.1,
    boost: { title: 5, keywords: 3, bigrams: 0.7 }
  });
  if (rA.length) return rA;
}


  // (B) 少し緩め：本文も含め AND。長文は prefix を切り fuzzy をごく弱く
  const rB = idx.search(q, {
    fields: ['title','keywords','plainContent','bigrams'],
    combineWith: 'AND',
    prefix: !isLongPhrase,
    fuzzy:  isLongPhrase ? 0.1 : 0,
    boost: { title: 5, keywords: 3, plainContent: 1, bigrams: 0.7 }
  });
  if (rB.length) return rB;

  // (C) 最終網：OR。ただし bigrams を除外し、fuzzy も弱く
  return idx.search(q, {
    fields: ['title','keywords','plainContent'],
    combineWith: 'OR',
    prefix: !isLongPhrase,
    fuzzy:  isLongPhrase ? 0.05 : 0,
    boost: { title: 5, keywords: 3, plainContent: 1 }
  });
}



async function searchArticleIdsByShards(query, shardKeys) {
  const ok = await ensureMiniSearchLoaded();
  if (!ok) return [];

  const hits = [];
  for (const key of shardKeys) {
    const idx = await loadIndexShard(key);
    if (!idx) continue;
    try {
      const r = smartSearch(idx, normalizeJaText(query));
      r.forEach(h => hits.push({ id: h.id || h.articleId, score: h.score, shard: key }));
    } catch (e) {
      console.warn(`[IDX] search failed on ${key}`, e);
    }
  }

  const best = new Map();
  for (const h of hits) {
    const prev = best.get(h.id);
    if (!prev || h.score > prev.score) best.set(h.id, h);
  }
  return Array.from(best.values())
    .sort((a,b) => (b.score||0) - (a.score||0))
    .map(h => h.id);
}


</script>




<script>


// ====== モーダル保護 一式 ======
const PROTECT_CFG = {
  copy: true,       // コピー/選択/右クリック/ドラッグ抑止
  print: true,      // モーダル開いてる間は印刷白紙
  devtools: false,   // DevTools検知でブラー＋任意アクション
  devtoolsAction: 'close', // ← ここを変更
  watermark: false   // 透かしは表示場所が微妙になるため入れない
};

let _protectCleanups = [];

/** モーダル保護を適用 */
function applyArticleProtections() {
  cleanupArticleProtections(); // 二重適用防止

  const modal = document.getElementById('articleModal');
  const content = modal.querySelector('.modal-content');
  if (!modal || !content) return;

  // 1) コピー/選択/右クリ/ドラッグ等を抑止（モーダル内のみ捕捉）
  if (PROTECT_CFG.copy) {
    const prevent = e => { e.preventDefault(); e.stopPropagation(); };
    const onCopy = e => { prevent(e); try { e.clipboardData?.setData('text/plain','コピーは無効です'); } catch(_){} };
    const typeTargets = [
      ['contextmenu', prevent, true],
      ['selectstart', prevent, true],
      ['dragstart',   prevent, true],
      ['copy',        onCopy,  true],
      ['cut',         prevent, true],
      ['paste',       prevent, true]
    ];
    typeTargets.forEach(([t,fn,opt]) => {
      content.addEventListener(t, fn, opt);
      _protectCleanups.push(()=>content.removeEventListener(t, fn, opt));
    });

    // キーボード経由のコピー/全選択/保存/印刷/ソース表示/F12など
    const onKeyDown = e => {
      const k = (e.key||'').toLowerCase();
      const ctrl = e.ctrlKey || e.metaKey;
      if (
        (ctrl && ['c','x','a','s','p','u'].includes(k)) || // Ctrl/Cmd + C/X/A/S/P/U
        e.key === 'F12' ||
        (ctrl && e.shiftKey && ['i','j','c'].includes(k))  // DevTools系
      ) { e.preventDefault(); e.stopPropagation(); }
    };
    document.addEventListener('keydown', onKeyDown, true);
    _protectCleanups.push(()=>document.removeEventListener('keydown', onKeyDown, true));

    // PrintScreen押下 → クリップボード上書き（対応ブラウザのみ）
    const onKeyUp = async e => {
      if (e.key === 'PrintScreen') {
        try { await navigator.clipboard.writeText('スクリーンショットは禁止されています'); } catch(_) {}
        alert('スクリーンショットはご遠慮ください。');
      }
    };
    document.addEventListener('keyup', onKeyUp, true);
    _protectCleanups.push(()=>document.removeEventListener('keyup', onKeyUp, true));
  }

  // 2) 印刷抑止（モーダル開いてる間だけ）
  if (PROTECT_CFG.print) {
    document.body.classList.add('modal-open');
    _protectCleanups.push(()=>document.body.classList.remove('modal-open'));
    const before = ()=>{};
    const after  = ()=>{};
    window.addEventListener('beforeprint', before);
    window.addEventListener('afterprint',  after);
    _protectCleanups.push(()=>window.removeEventListener('beforeprint', before));
    _protectCleanups.push(()=>window.removeEventListener('afterprint',  after));
  }

  // 3) DevTools検知（簡易）：ウィンドウ枠サイズ差で推定
  if (PROTECT_CFG.devtools) {
    const check = () => {
      const th = 160; // パネル幅のしきい値
      const opened =
        (window.outerWidth - window.innerWidth > th) ||
        (window.outerHeight - window.innerHeight > th);

      document.body.classList.toggle('devtools-open', !!opened);

      if (!opened) return;

      // DevTools 開いた瞬間の挙動
      if (PROTECT_CFG.devtoolsAction === 'close') {
        try {
          const modal = document.getElementById('articleModal');
          const content = modal?.querySelector('.content');
          if (content) {
            // 本文を完全削除（テキスト残さない）
            content.innerHTML = '<p class="article-loading-message">DevTools検知のため本文を非表示にしました。</p>';
          }

          // 復号鍵や一時キャッシュもできるだけ破棄
          if (window.__lastOpenKey) window.__lastOpenKey = null;

          // モーダルを閉じる（padding等の後片付け含め）
          if (typeof closeArticlePopup === 'function') {
            closeArticlePopup();
          } else if (modal) {
            modal.style.display = 'none';
            document.body.style.overflow = '';
          }
        } catch (e) {
          console.warn('[protect] close-on-devtools failed', e);
        }
      }

      if (PROTECT_CFG.devtoolsAction === 'logout') {
        try { auth?.signOut?.(); } catch(_) {}
      }
    };

    const id = setInterval(check, 600);
    _protectCleanups.push(() => clearInterval(id));

    const onResize = () => check();
    window.addEventListener('resize', onResize);
    _protectCleanups.push(() => window.removeEventListener('resize', onResize));
  }

  // 4) 透かし（閲覧者メール＋時刻）
  if (PROTECT_CFG.watermark) {
    const email = auth?.currentUser?.email || 'member';
    const text  = `${email} · ${new Date().toLocaleString()}`;
    const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="380" height="220">
        <text x="0" y="60" fill="rgba(0,0,0,.15)" font-size="20" font-family="Arial, sans-serif"
              transform="rotate(-30, 0, 0)">${text}</text>
      </svg>`;
    const data = `url("data:image/svg+xml;utf8,${encodeURIComponent(svg)}")`;
    content.style.backgroundImage = data;
    content.style.backgroundRepeat = 'repeat';
    content.style.backgroundSize = '380px 220px';
    _protectCleanups.push(()=>{
      content.style.backgroundImage = '';
      content.style.backgroundRepeat = '';
      content.style.backgroundSize   = '';
    });
  }
}

/** モーダル保護を解除（close時に呼ぶ） */
function cleanupArticleProtections() {
  try { _protectCleanups.forEach(fn => fn()); } catch(_){}
  _protectCleanups = [];
}



</script>





<script src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js"></script>


<script>
  // CJKは1文字単位、英数は単語ごとに分割して行折返しを安定化
  function splitForCJK(str) {
    const out = [];
    let buf = "";
    for (const ch of String(str)) {
      // 漢字・ひら・カタカナ・半角カナの判定（index.html内に同種の正規表現あり）
      const isCJK = /[\u3400-\u9FFF\uF900-\uFAFF\u3040-\u309F\u30A0-\u30FF\u31F0-\u31FF\uFF65-\uFF9F]/.test(ch);
      if (isCJK) {
        if (buf) { out.push(buf); buf = ""; }
        out.push(ch);            // CJKは1文字ずつ
      } else if (/\s/.test(ch)) {
        if (buf) { out.push(buf); buf = ""; }
        out.push(ch);            // 空白は空白として
      } else {
        buf += ch;               // 英数は単語で貯める
      }
    }
    if (buf) out.push(buf);
    return out;
  }
</script>


<script>


  // プレーンフォールバック（/build_plain_articles/<slug>.json）
  async function fetchPlainArticle(slug, urlOverride){
   const url = urlOverride || `/build_plain_articles/${encodeURIComponent(slug)}.json`;
    const res=await fetch(url, { cache:"no-store" });
    if(!res.ok) throw new Error(`plain http ${res.status}`);
    const j=await res.json();
    return {
      title: j.title||"",
      subtitle1: j.subtitle1||"",
      subtitle2: j.subtitle2||"",
      publishDate: j.publishDate||"",
      issueNumber: j.issue||j.issueNumber||"",
      content: j.htmlContent||j.body||""
    };
  }

// ===== モーダル記事表示（履歴つき） =====

// モーダル内の「記事履歴」と「今表示しているslug」
window.articleModalHistory = [];
window.currentArticleSlug  = null;

// 一覧→モーダルの戻るボタン用 HTML 生成
function generateArticleHtml(a){
  const safeTitle = (a.title || "").replace(/</g,"&lt;");
  const safeSub1  = (a.subtitle1 || "").replace(/</g,"&lt;");
  const safeSub2  = (a.subtitle2 || "").replace(/</g,"&lt;");

  return `
    <div class="header-section">
      <div class="logo-text"></div>
      <div class="meta-info">
        ${a.publishDate ? `発行：${a.publishDate}` : "号"}
        ${a.issueNumber ? ` / ${a.issueNumber}` : "号"}
      </div>
    </div>
    <div class="title-section">
      <h1 class="main-title">${safeTitle}</h1>
      ${a.subtitle1 ? `<h2 class="subtitle">${safeSub1}</h2>` : ""}
      ${a.subtitle2 ? `<h3 class="subtitle">${safeSub2}</h3>` : ""}
    </div>
    <div class="content">${a.content || ""}</div>
    <div class="button-container">
      <!-- 一覧に戻るボタンは「完全クローズ」専用 -->
      <a class="back-button"
   href="#"
   onclick="closeArticlePopup(); return false;">
  元の記事に戻る
</a>

<a class="back-button"
   href="#"
   onclick="closeArticlePopup({ forceClose: true }); return false;">
  一覧に戻る
</a>

    </div>
    <div class="ad-sticky">
      <div id="modalAdGrid" class="ad-grid"></div>
    </div>
  `;
}



// Worker から JSON を取ってくるだけの関数
async function fetchArticleJson(slug) {
  const url = `${WORKER_URL}/${encodeURIComponent(slug)}`;
  const res = await fetch(url, { cache: "no-store" });

  if (res.status === 404) {
    throw new Error(`記事が見つかりません (slug=${slug})`);
  }
  if (!res.ok) {
    throw new Error(`Worker error ${res.status}`);
  }
  return await res.json(); // Workerは復号済みJSONを返す想定
}

function bindInternalLinkHandlerOnce(boxEl) {
  if (!boxEl) return;
  if (boxEl.__boundInternalLink) return;
  boxEl.__boundInternalLink = true;

  boxEl.addEventListener("click", (e) => {
    const a = e.target.closest('a[data-slug], a[href^="#internal:"]');
    if (!a) return;

    const href = a.getAttribute("href") || "";
    const slug =
      (a.dataset && a.dataset.slug) ||
      (href.startsWith("#internal:") ? href.slice("#internal:".length) : "");

    if (!slug) return;

    e.preventDefault();
    e.stopPropagation();

    // 同じモーダルの中身を差し替え表示（履歴に積む）
    openArticleCanvas(String(slug).trim(), { pushHistory: true });
  });
}


// これが“唯一の”オープナー（JSON前提＋履歴管理）
async function openArticleCanvas(slug, { pushHistory = true } = {}) {
window.openArticleCanvas = openArticleCanvas;
window.fetchArticleJson = fetchArticleJson;
  const overlay = document.getElementById('articleModal');
  const box     = document.getElementById('modalContent');

  if (!overlay || !box) {
    console.error('[openArticleCanvas] modal elements not found');
    return;
  }

(function bindArticleModalOverlayCloseOnce(){
  const overlay = document.getElementById('articleModal');
  if (!overlay) return;

  // 二重登録防止
  if (overlay.__boundClose) return;
  overlay.__boundClose = true;

  overlay.addEventListener('click', (event) => {
    if (event.target === overlay) {
      closeArticlePopup({ forceClose: true });
    }
  });
})();



  // 直前に別の記事を表示していたら履歴に積む
  const prev = window.currentArticleSlug;
  if (pushHistory && prev && prev !== slug) {
    window.articleModalHistory.push(prev);
  }
  window.currentArticleSlug = slug;

  overlay.style.display = 'flex';
  document.body.style.overflow = 'hidden';
  box.innerHTML = '<p class="article-loading-message">記事を読み込み中...</p>';

  try {
    // ① Worker から復号済みJSONを取得
    const dec = await fetchArticleJson(slug);

    // ② 表示用に整形
    const a = {
      title:       dec.title       || "",
      subtitle1:   dec.subtitle1   || "",
      subtitle2:   dec.subtitle2   || "",
      publishDate: dec.publishDate || "",
      issueNumber: dec.issue || dec.issueNumber || "",
      content:     dec.body || dec.htmlContent || ""
    };

    box.innerHTML = generateArticleHtml(a);

// ★追加：本文内の internal link を拾う（1回だけバインド）
bindInternalLinkHandlerOnce(box);

    // 本文内リンク・号数リンク
    try { linkifyIssueRefs?.(box); } catch(_){}
    try { enhanceArticleLinks?.(box); } catch(_){}
    try { resolvePendingIssueLinks?.(box); } catch(_){}


    // コピー禁止・DevTools検知など
    try { applyArticleProtections?.(); } catch(_){}

    // GA
    try {
      window.gtag?.('event','view_item',{
        item_id: slug,
        item_name: a.title || slug
      });
    } catch(_){}

  } catch (e1) {
    console.warn('[openArticleCanvas] Worker JSON failed → plain fallback', e1);

    try {
      // ③ Workerがダメなときは、build_plain_articles のプレーンJSONにフォールバック
      const a = await fetchPlainArticle(slug);
      box.innerHTML = generateArticleHtml(a);
// ★追加
bindInternalLinkHandlerOnce(box);

      try { linkifyIssueRefs?.(box); } catch(_){}
      try { enhanceArticleLinks?.(box); } catch(_){}
      try { resolvePendingIssueLinks?.(box); } catch(_){}
      try {
        const g = box.querySelector('#modalAdGrid');
        g && renderModalAdsInto?.(g);
      } catch(_){}
      try { applyArticleProtections?.(); } catch(_){}
      try {
        window.gtag?.('event','view_item',{
          item_id: slug,
          item_name: a.title || slug
        });
      } catch(_){}

    } catch (e2) {
      console.error('[openArticleCanvas] fallback plain failed', e2);
      box.innerHTML =
        `<p class="article-loading-message" style="color:red;">記事の読み込みに失敗しました。</p>`;
    }
  }
}

// 古いコード互換
window.openArticleCanvas = openArticleCanvas;
window.showArticlePopup  = openArticleCanvas;

// 閉じる：
//  - 履歴があれば「一つ前の記事」に戻る
//  - 履歴が空か forceClose=true のときは完全クローズ
function closeArticlePopup(options = {}) {
  const { forceClose = false } = options;

  // 戻り先がある & 強制クローズでない → ひとつ前の記事に戻る
  if (!forceClose && window.articleModalHistory.length > 0) {
    const backSlug = window.articleModalHistory.pop();
    if (backSlug) {
      // 戻るときは pushHistory=false（また履歴を積まない）
      openArticleCanvas(backSlug, { pushHistory: false });
      return;
    }
  }

  // ここまで来たら完全に閉じる
  const modal = document.getElementById('articleModal');
  if (modal) modal.style.display = 'none';
  document.body.style.overflow = '';

  // 状態リセット
  window.articleModalHistory = [];
  window.currentArticleSlug  = null;

  try { renderAdDrawer?.(); } catch(_){}
  try { cleanupArticleProtections?.(); } catch(_){}
}
window.closeArticlePopup = closeArticlePopup;

</script>


<script>
document.addEventListener("DOMContentLoaded", async () => {
  try {
    await window.loadArticles();
  } catch (e) {
    console.error("[BOOT] loadArticles failed:", e);
    const el = document.getElementById("searchResults");
    if (el) {
      el.innerHTML = '<div class="search-message">記事データの読み込みに失敗しました。</div>';
    }
  }
});
</script>



<script>
(function () {
  function getSlugFromElement(el) {
    if (!el) return "";

    // 1) data-slug 最優先（datasetより attribute の方が堅い）
    const a1 = el.getAttribute?.("data-slug");
    if (a1) return String(a1).trim();

    const a2 = el.dataset?.slug;
    if (a2) return String(a2).trim();

    // 2) 互換
    const a3 = el.getAttribute?.("data-article-id") || el.dataset?.articleId;
    if (a3) return String(a3).trim();

    const a4 = el.getAttribute?.("data-id") || el.dataset?.id;
    if (a4) return String(a4).trim();

    // 3) href fallback
    const href = el.getAttribute?.("href") || "";
    const m =
      href.match(/slug=([^&#]+)/) ||
      href.match(/^#internal-(.+)$/) ||
      href.match(/^#open:(.+)$/);

    return m ? decodeURIComponent(m[1]).trim() : "";
  }

  document.addEventListener(
    "click",
    (e) => {
      const linkEl = e.target.closest(
        'a.article-link, a.js-article, .article-item a, a[data-slug], [data-slug]'
      );
      if (!linkEl) return;

      e.preventDefault();
      e.stopPropagation();

      const slug = getSlugFromElement(linkEl);

      // ★デバッグ（あとで消してOK）
      console.log("[OPEN] linkEl=", linkEl, "attr data-slug=", linkEl.getAttribute?.("data-slug"), "slug=", slug);

      if (!slug) {
        console.warn("[OPEN] no slug on click", linkEl);
        alert("この記事の識別子(slug)が見つかりませんでした。data-slug を確認してください。");
        return;
      }

      if (typeof window.openArticleCanvas === "function") {
  window.openArticleCanvas(slug);
} else {
  console.warn("[OPEN] window.openArticleCanvas is not defined");
}
    },
    true
  );
})();


</script>



<!-- これを </body> のちょっと上に置く（CSSとJSの想定IDに一致） -->
<div id="articleModal" class="modal-overlay" style="display:none;">
  <div class="modal-content">
    <span class="close-button" onclick="closeArticlePopup()">×</span>
    <div id="modalContent" class="content"></div>

    <div class="ad-sticky">
      <div id="modalAdGrid" class="ad-grid"></div>
    </div>
  </div>
</div>


<!-- ★必ずこの後に app.js を読む -->
<script src="/app.js?v=2025-11-27-4"></script>

<script>
  (() => {
    const VIEWER_BASE = "https://kjd-viewer-assets.pages.dev/";
    const btn = document.getElementById("btn-latest-issue");
    if (!btn) return;
    btn.addEventListener("click", () => location.href = VIEWER_BASE);
  })();
</script>
</body>


</body>
</html>
